<!DOCTYPE html>
<html>
  <head>
    <title>Yaman's Interactive Particles</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>

    <script>
      AFRAME.registerComponent('particle-master', {
        schema: {
          count: { type: 'int', default: 15000 },
          color: { type: 'color', default: '#00FFFF' }
        },

        init: function () {
          this.currentShapeIndex = 0;
          this.shapes = []; 
          this.lastTriggerTime = 0; // Debounce ke liye

          // Hands ke references
          this.leftHand = document.querySelector('#leftHand');
          this.rightHand = document.querySelector('#rightHand');
          this.debugText = document.querySelector('#debugText');

          // --- 1. THREE.JS SETUP ---
          const particleCount = this.data.count;
          this.geometry = new THREE.BufferGeometry();
          this.positions = new Float32Array(particleCount * 3);
          this.targetPositions = new Float32Array(particleCount * 3);
          
          // Initial Random Positions
          for (let i = 0; i < particleCount * 3; i++) {
            this.positions[i] = (Math.random() - 0.5) * 5;
            this.targetPositions[i] = this.positions[i];
          }

          this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));

          this.material = new THREE.PointsMaterial({
            color: this.data.color,
            size: 0.02, // Starting Size
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
          });

          this.particleSystem = new THREE.Points(this.geometry, this.material);
          this.el.setObject3D('mesh', this.particleSystem);

          // --- 2. GENERATE SHAPES ---
          this.generateShapes();
        },

        generateShapes: function() {
          const count = this.data.count;
          
          // Shape 0: Sphere (Gola)
          const sphere = [];
          for (let i = 0; i < count; i++) {
            const r = 1.0;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            sphere.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
          }
          this.shapes.push(sphere);

          // Shape 1: Cube (Dabba)
          const cube = [];
          for (let i = 0; i < count; i++) {
             cube.push((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
          }
          this.shapes.push(cube);

          // Shape 2: Galaxy Spiral
          const galaxy = [];
          for(let i=0; i<count; i++){
             const angle = i * 0.02;
             const r = (i/count) * 2; 
             galaxy.push(Math.cos(angle)*r, (Math.random()-0.5)*0.5, Math.sin(angle)*r);
          }
          this.shapes.push(galaxy);

          // Shape 3: Heart
          const heart = [];
          for (let i = 0; i < count; i++) {
             let t = Math.random() * Math.PI * 2;
             let r = 0.05; 
             let x = 16 * Math.pow(Math.sin(t), 3);
             let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
             heart.push(x * r, y * r + 0.5, (Math.random()-0.5));
          }
          this.shapes.push(heart);
        },

        nextShape: function() {
          const now = Date.now();
          if (now - this.lastTriggerTime < 1000) return; // 1 second delay
          this.lastTriggerTime = now;

          this.currentShapeIndex = (this.currentShapeIndex + 1) % this.shapes.length;
          const newShape = this.shapes[this.currentShapeIndex];
          
          // Naye shape ke targets set karo
          for(let i=0; i < this.targetPositions.length; i++) {
             this.targetPositions[i] = newShape[i];
          }
          
          // Color change effect
          this.material.color.setHSL(Math.random(), 1, 0.5);
        },

        tick: function (t, dt) {
          if (!this.leftHand || !this.rightHand) return;

          const leftPos = this.leftHand.object3D.position;
          const rightPos = this.rightHand.object3D.position;
          const handDistance = leftPos.distanceTo(rightPos);

          // --- LOGIC 1: SIZE CHANGE (Based on Hand Distance) ---
          // Agar haath track ho rahe hain (distance > 0.1)
          if (handDistance > 0.1) {
             // Size formula: Distance jitna bada, size utna bada
             let newSize = 0.01 + (handDistance * 0.05);
             if (newSize > 0.15) newSize = 0.15; // Max limit
             this.material.size = newSize;
          }

          // --- LOGIC 2: FOLLOW RIGHT HAND (Movement) ---
          // Particles system Right Hand ko follow karega thoda delay ke sath
          // 'Lerp' use kar rahe hain smooth movement ke liye
          this.el.object3D.position.lerp(rightPos, 0.05);
          
          // Rotation effect (Slowly rotate)
          this.el.object3D.rotation.y += 0.002;
          this.el.object3D.rotation.z += 0.001;


          // --- LOGIC 3: SHAPE CHANGE (Manual Pinch Detection) ---
          // Note: WebXR mein exact pinch data nikalna complex hai bina extra library ke.
          // Isliye hum yahan ek simple hack use karenge: 
          // Agar Right Hand aur Left Hand ekdum touch ho jaye (Clap/Touch), toh shape badlegi.
          // Kyunki ungliyon ka data nikalna mushkil hai standard component se.
          
          if (handDistance < 0.15) { // Agar dono haath 15cm se paas hain
             this.nextShape();
          }

          // --- ANIMATION UPDATE ---
          const positions = this.geometry.attributes.position.array;
          const speed = 4 * (dt / 1000); 

          for (let i = 0; i < positions.length; i++) {
            // Target position ki taraf move karo
            positions[i] += (this.targetPositions[i] - positions[i]) * speed;
          }
          this.geometry.attributes.position.needsUpdate = true;
          
          // Debug Text update
          if (this.debugText) {
            this.debugText.setAttribute('value', `Size: ${this.material.size.toFixed(3)}\nTouch Hands to Morph!`);
          }
        }
      });
    </script>
  </head>
  <body>
    <a-scene>
      <a-entity environment="preset: starry; groundColor: #000; grid: none"></a-entity>

      <a-entity particle-master="count: 15000; color: #00FFFF" position="0 1.6 -1"></a-entity>

      <a-entity id="leftHand" hand-tracking-controls="hand: left"></a-entity>
      <a-entity id="rightHand" hand-tracking-controls="hand: right"></a-entity>

      <a-text id="debugText" value="Loading..." position="0 2.5 -2" align="center" color="#FFF"></a-text>
      
      <a-entity camera look-controls position="0 1.6 0"></a-entity>
    </a-scene>
  </body>
</html>
